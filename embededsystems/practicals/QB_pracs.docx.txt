Practical 1


Aim: Design and develop a reprogrammable embedded computer using 8051
microcontrollers and to show the following aspects.
a. Programming
b. Execution
c. Debugging


Software Requirements: Keil, Proteus.


Description:
A reprogrammable can be considered as an embedded system which can be reprogrammed number of times easily, while providing flexibility. In other words, we can say that for a reprogrammable embedded system, Microcontroller unit can be reprogrammed without actually completely pulling out the MCU.
The reprogrammable microcontroller based embedded system also provides debug facility for users.


Code:
#include<reg52.H>
sbit LED = P2^0;
void Delay(void);
void main(void)
{
        while(1)
        {
                LED = 0;
                Delay();
                LED = 1;
                Delay();
        }
}
void Delay(void)
{
        int j;
        int i;
        for(i = 0; i < 10; i++)
        {
                for(j = 0; j < 10000; j++)
                {
                }
        }
}
__________________________________________________________________________
Practical 2.A


Aim:Configure timer control registers of 8051 and develop a program to generate
given time delay.


Software Requirements: Keil, Proteus.


Calculation of delay:
Consider the crystal frequency, that for 8051 is XTAL = 11.0592 MHz (12MHz).
Each machine cycle is divided into 12 clock cycles hence, clock frequency is –
11.0592 / 12 = 0.9216
Clock period = 1 / 0.9216 = 1.085 µsec
To generate a delay of specific time, a loop is executed, say n times.
For 1s, n = 1000 ms / 1.085 µsec = 921.658
As 8051 microcontroller uses relative addressing, jump is made FFFF – n no of
times. Thus,
65536 (FFFF H) – n = N
For 1s, N = 65536 - 921.658 = 64614.34
convert N to hex yyxx
For 1s hex value of N = FC65 H
Set TL = xx and TH = yy
For 1s TL = 65H and TH = FCH


Code:
#include<REG51.H>
void T0Delay(void);
void main(void)
{
while (1)
{
P1=0xFF; 
ToDelay();
P1=0x00; 
ToDelay(); 
}
}
void ToDelay() //delay function
{
TMOD=0x01; 
TL0=0xFC; 
TH0=0x65;
TR0=1; 
while (TF0==0); 
TR0=0; 
TF0=0; 
}




Practical 3.A


Aim: Port I / O: Use one of the four ports of 8051 for O/P interfaced to eight LED’s. Simulate binary counter (8 bit) on LED’s


Software Requirements: Keil, Proteus.


Code:
#include<reg51.h>
void delay(int time);
void main()
{
        P1 = 00000000;
        while(1)
        {
                P1++;
                delay(100);
        }
}


void delay(int time)
{
        int i, j;
        for(i = 0; i <= time; i++)
        {
                for(j = 0; j <= 23; j++)
                {
                }
        }
                
}
__________________________________________________________________________


Practical 3.B


Aim:To interface 8 LEDs at Input-output port and create different patterns.


Software Requirements: Keil, Proteus.


Code:


#include<reg51.h>
void delay();


void main()
{
        while(1)
        {
                P1 = 0xAA; // Pattern to turn on alternate LEDs - 10101010
                delay();
                P1 = 0x55; // Reverse the pattern
                delay();
        }
}


void delay()
{
        unsigned int i, j;
        for(i = 0; i < 23; i++)
        {
                for(j = 0; j < 1000; j++)
                {
                }
        }
}


__________________________________________________________________________


Practical 4


Aim: To demonstrate timer working in timer mode and blink LED without using any loop delay routine.


Software Requirements: Keil, Proteus.


Code:


#include<reg51.h>
int i = 0;


void timer_ISR(void)interrupt 1
{
        i++;
        if(i == 10)
        {
                i=0;
                P1++;
        }
}


void main(void)
{
        TMOD = 0x01;
        ET0 = 1;
        TR0 = 1;
        EA = 1;
        while(1);
}


__________________________________________________________________________


Practical 6


Aim: To demonstrate interfacing of a seven-segment LED display and generate counting from 0 to 99 with fixed time delay.
        
Software Requirements: Keil, Proteus.


Code:


#include<reg51.h>
void delay(unsigned int ms)
{
        unsigned int i, j;
        for(i = 0; i<ms; i++)
        {
                for(j = 0; j<=1275; j++)
                {
                }
        }
}


void main(void)
{
        char number[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
        int i, j;
        P2 = 0x00;
        P3 = 0x00;
        while(1)
        {
                for(i = 0; i<=9; i++)
                {
                        P2 = number[i];
                        for(j = 0; j<=9; j++)
                        {
                                P3 = number[j];
                                delay(50);
                        }
                }
        }
}
__________________________________________________________________________




Practical 7.A


Aim: Interface 8051 with D/A converter and generate square wave of given frequency on oscilloscope.
        
Software Requirements: Keil, Proteus.


Code:


#include<reg51.h>
void delay();
void main()
{
        P2 = 0x00;
        while(1)
        {
                P2 = 0xFF;
                delay();
                P2 = 0x00;
                delay();
        }
}
void delay()
{
        int i;
        for(i = 0; i <= 5000; i++)
        {
        }
}




__________________________________________________________________________




Practical 10


Aim: Generate traffic signal.        
Software Requirements: Keil, Proteus.


Code:


#include<reg51.h>
sbit red=P1^0;
sbit yellow=P1^1;
sbit green=P1^2;
void main()


{
unsigned int i;
red=yellow=green=0;
while(1)
{
red=1;
yellow=green=0;
for(i=0;i<60000;i++)
{
for(i=0;i<60000;i++){ }
}
red=0;


green=1;
yellow=red=0;
for(i=0;i<60000;i++)
{
for(i=0;i<60000;i++){}
}
green=0;


yellow=1;


green=red=0;
for(i=0;i<40000;i++)
{
for(i=0;i<40000;i++){}
}
yellow=0;
}
}


__________________________________________________________________________